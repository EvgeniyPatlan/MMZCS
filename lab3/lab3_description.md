### Опис алгоритму

#### 1. Генерація сеансового ключа
Алгоритм починається з генерації **сеансового ключа** за допомогою **алгоритму Лемера (Lehmer RNG)**, який є одним із видів лінійного конгруентного генератора випадкових чисел. Для генерації ключа використовується початкове значення (сід), множник і модуль. В результаті отримується випадкове число, яке буде використовуватись як сеансовий ключ. Довжина ключа визначається параметром `2w`, де `w` — це розрядність блоку даних.

Сеансовий ключ зберігається у файлі `s_key.txt`. Цей ключ буде використано для подальшого шифрування даних під час сеансу зв’язку.

#### 2. Генерація управляючого вектора
Після генерації сеансового ключа відбувається генерація **управляючого вектора**, який контролює параметри використання ключа. Для цього також використовується **алгоритм Лемера**, але з іншим початковим значенням і модулем, який визначається параметром `5N`. Управляючий вектор є важливим для шифрування сеансового ключа та забезпечує додатковий рівень захисту, визначаючи обмеження на його використання.

#### 3. Хешування управляючого вектора за допомогою RXOR
Наступним кроком є хешування управляючого вектора за допомогою **алгоритму RXOR**. RXOR — це простий алгоритм, що застосовує операцію XOR до всіх байтів управляючого вектора. Кожен символ вектора перетворюється на своє ASCII-представлення, і для всіх цих значень виконується операція XOR, результатом якої є **хеш управляючого вектора**.

Хешування управляючого вектора є важливим етапом для подальшого створення ключа шифрування, оскільки цей хеш буде поєднано з майстер-ключем користувача.

#### 4. Введення майстер-ключа
Користувач вводить **майстер-ключ**, який є бінарним (складається з 0 і 1). Майстер-ключ вводиться через консоль і проходить перевірку на коректність — перевіряється, щоб ключ містив лише 0 та 1. Довжина майстер-ключа визначається параметром `N`, який зазвичай становить 16 біт або більше, залежно від розмірності ключа.

Майстер-ключ є основним ключем для шифрування сеансового ключа, що гарантує безпеку передачі ключів між сторонами.

#### 5. Обчислення ключа шифрування
Для шифрування сеансового ключа застосовується операція **XOR** між майстер-ключем користувача і хешованим управляючим вектором. Це дозволяє створити **ключ шифрування**, який унікально залежить як від введеного користувачем майстер-ключа, так і від управляючого вектора.

Такий підхід дозволяє гарантувати, що зашифрований сеансовий ключ не може бути відновлений без правильного майстер-ключа і управляючого вектора.

#### 6. Шифрування сеансового ключа
Сеансовий ключ, що був збережений у файлі `s_key.txt`, зашифровується за допомогою ключа, отриманого в результаті операції XOR між майстер-ключем і хешем управляючого вектора. Для шифрування використовується операція **XOR** між кожним байтом сеансового ключа і відповідним байтом ключа шифрування.

Процес шифрування забезпечує, що навіть у разі перехоплення зашифрованого сеансового ключа, його не можна відновити без знання як майстер-ключа, так і хешованого управляючого вектора.

#### 7. Збереження зашифрованого сеансового ключа
Зашифрований сеансовий ключ зберігається у файлі `m_key.txt`. Цей ключ буде використаний для передачі між сторонами, які спілкуються. Отримавши зашифрований сеансовий ключ, отримувач може розшифрувати його за допомогою свого майстер-ключа та управляючого вектора, таким чином відновивши оригінальний сеансовий ключ для подальшого шифрування даних під час сеансу зв’язку.

#### 8. Виведення результатів
Після успішного шифрування сеансового ключа, користувачу виводяться на екран наступні результати:
- **Сеансовий ключ** у його початковій (незашифрованій) формі.
- **Зашифрований сеансовий ключ**, який був збережений у файл `m_key.txt`.

Це підтверджує успішне виконання алгоритму шифрування та готовність до передачі ключів.

### Загальні висновки
Алгоритм забезпечує надійну генерацію та шифрування сеансових ключів, використовуючи симетричні операції шифрування та хешування. Генерація ключів відбувається за допомогою простого генератора випадкових чисел Лемера, а шифрування здійснюється через операцію XOR. Управляючий вектор та хешування через RXOR забезпечують додатковий рівень захисту.

### Кроки роботи скрипта `lab1.pl`:

### 1. **Читання параметрів командного рядка**
   Користувач передає параметри:
   - `--input` – ім'я вхідного файлу.
   - `--encrypted` – ім'я файлу для збереження зашифрованого результату.
   - `--decrypted` – ім'я файлу для збереження розшифрованого результату.
   - `--polynomial` – поліном (в десятковому вигляді) для генерації зворотного зв'язку в LFSR.
   - `--init_value` – початкове значення для ініціалізації стану регістру зсуву.
   - `--size` – кількість бітів у регістрі.

### 2. **Ініціалізація регістру зсуву (LFSR)**
   Регістри зсуву – це бінарні послідовності, які зсувають біти на основі зворотного зв'язку (XOR) визначених бітів за допомогою полінома.

#### Поліном і стан:
   - Поліном визначає, які біти будуть використовуватися для XOR. Наприклад, поліном 285 (в двійковій формі `100011101`).
   - Початковий стан визначається користувачем, наприклад, значення 12345 (у двійковій формі `11000000111001`).
   
#### Процес зсуву регістру:
   На кожному кроці:
   - Молодший біт (LSB) регістру використовується для формування ключового потоку.
   - Інші біти регістру зсуваються вправо.
   - Зворотний біт формується за допомогою операції XOR між бітами, визначеними поліномом, і поміщається в старший розряд.

#### Приклад зсуву регістру:
   Припустимо, що початковий стан – `11000000111001` (12345), а поліном – 285 (`100011101`).
   
   **1-й крок:**
   - Візьмемо LSB: `1` (ключовий біт).
   - Зсув вправо: `01100000011100`.
   - XOR між бітами 1-го, 3-го, 6-го і 9-го (згідно з поліномом): результат XOR – `1`.
   - Додаємо зворотний біт: новий стан – `11100000011100`.
   
   **2-й крок:**
   - Візьмемо LSB: `0` (ключовий біт).
   - Зсув вправо: `01110000001110`.
   - XOR бітів згідно з поліномом: результат XOR – `0`.
   - Новий стан: `00111000001110`.

Цей процес триває, поки не згенерується необхідна кількість бітів (зазвичай це кількість бітів у вхідному файлі).

### 3. **Генерація ключового потоку**
   Після ініціалізації регістр зсуву генерує ключовий потік потрібної довжини. Кількість бітів у потоці повинна дорівнювати кількості бітів у вхідному файлі (розмір файлу в байтах * 8).
   
   **Приклад:**
   Для файлу розміром 3 байти (24 біти) ключовий потік також має містити 24 біти. Наприклад, ключовий потік: `110000101011000010111101`.

### 4. **Операція шифрування та розшифрування (XOR)**
   Для кожного байта вхідного файлу виконується побітова операція XOR між байтами вхідного файлу та відповідними бітами ключового потоку.
   
   #### Приклад шифрування:
   Припустимо, що вхідний байт – `11101101` (237), а відповідні біти ключового потоку – `10001111`.
   - **Перший біт:** XOR між `1` (вхідний) і `1` (ключ) дає `0`.
   - **Другий біт:** XOR між `1` (вхідний) і `0` (ключ) дає `1`.
   - І так далі для кожного біта:
     - Результат XOR: `01100010` (98).
   - Шифрований байт – `01100010` (98).
   
   Операція розшифрування така ж, оскільки XOR з тим самим ключем знову відновить оригінальний байт.

### 5. **Запис зашифрованих/розшифрованих файлів**
   Після шифрування скрипт записує результат у файл для збереження зашифрованих даних. Після розшифрування записується результат розшифрованого файлу.

### 6. **Порівняння файлів**
   Після розшифрування скрипт порівнює байт за байтом оригінальний файл і розшифрований файл.
   - Якщо всі байти однакові, шифрування та розшифрування виконані успішно.
   - Якщо знайдено різницю між байтами, це вказує на помилку в алгоритмі або процесі шифрування/розшифрування.

### 7. **Логування**
   Кожна операція шифрування та розшифрування записується у лог-файл:
   - **Ініціалізація LFSR:** Початковий стан і поліном.
   - **Кожен крок LFSR:** Новий стан регістру та ключові біти.
   - **Операції XOR:** Оригінальний байт, ключові біти та результат XOR.
   - **Порівняння файлів:** Результат порівняння (байти збігаються або відрізняються).

### Висновок:
Цей алгоритм використовує LFSR для генерації псевдовипадкового ключового потоку і застосовує його для шифрування/розшифрування даних за допомогою XOR.
